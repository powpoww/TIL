**참조 : https://wikidocs.net/1669**



## 1. 정규 표현식 살펴보기

- 정규 표현식(Regular Expression, 정규식)은 복잡한 문자열을 처리할 때 사용하는 기법



**정규식 사용 예시>**

```
주민등록번호를 포함하고 있는 텍스트가 있다. 이 텍스트에 포함된 모든 주민등록번호의 뒷자리를 * 문자로 변경해 보자.
```

우선 정규식을 전혀 모르면 다음과 같은 순서로 프로그램을 작성해야 할 것이다.

1. 전체 텍스트를 공백 문자로 나눈다(split).
2. 나뉜 단어가 주민등록번호 형식인지 조사한다.
3. 단어가 주민등록번호 형식이라면 뒷자리를 `*`로 변환한다.
4. 나뉜 단어를 다시 조립한다.

```python
data = """
park 800905-1049118
kim  700905-1059119
"""

result = []
for line in data.split("\n"):
    word_result = []
    for word in line.split(" "):
        if len(word) == 14 and word[:6].isdigit() and word[7:].isdigit():
            word = word[:6] + "-" + "*******"
        word_result.append(word)
    result.append(" ".join(word_result))
print("\n".join(result))
```

반면 정규식을 사용하면 간편하고 직관적으로 코드를 작성할 수 있다.

```python
import re 

data = """
park 800905-1049118
kim  700905-1059119
"""

pat = re.compile("(\d{6})[-]\d{7}")
print(pat.sub("\g<1>-*******", data))
```



## 2. 정규 표현식 시작



### 2.1 정규 표현식의 기초 메타 문자

- 메타 문자란 원래 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는 문자. : `. ^ $ * + ? { } [ ] \ | ( )`



#### 2.1.1 문자 클래스 [ ]

1. 문자 클래스를 만드는 메타 문자인 [ ] 사이에는 어떤 문자도 들어갈 수 있다. 즉 정규 표현식이 [abc]라면 이 표현식의 의미는 "a, b, c 중 한 개의 문자와 매치"를 뜻함.

   **예시>  "a", "before", "dude"가 정규식 [abc]와 어떻게 매치되는가?**

   - "a"는 정규식과 일치하는 문자인 "a"가 있으므로 매치
   - "before"는 정규식과 일치하는 문자인 "b"가 있으므로 매치
   - "dude"는 정규식과 일치하는 문자인 a, b, c 중 어느 하나도 포함하고 있지 않으므로 매치되지 않음
     

2.  [ ] 안의 두 문자 사이에 하이픈(-)을 사용하면 두 문자 사이의 범위(From - To)를 의미

   - [a-zA-Z] : 알파벳 모두
   - [0-9] : 숫자

3.  문자 클래스 안에 `^` 메타 문자를 사용할 경우에는 반대(not)라는 의미를 갖음.

   -  `[^0-9]`라는 정규 표현식은 숫자가 아닌 문자만 매치



**[자주 사용하는 문자 클래스]**

[0-9] 또는 [a-zA-Z] 등은 무척 자주 사용하는 정규 표현식이다. 이렇게 자주 사용하는 정규식은 별도의 표기법으로 표현할 수 있다. 다음을 기억해 두자.

- `\d` - 숫자와 매치, [0-9]와 동일한 표현식이다.
- `\D` - 숫자가 아닌 것과 매치, `[^0-9]`와 동일한 표현식이다.
- `\s` - whitespace 문자와 매치, `[ \t\n\r\f\v]`와 동일한 표현식이다. 맨 앞의 빈 칸은 공백문자(space)를 의미한다.
- `\S` - whitespace 문자가 아닌 것과 매치, `[^ \t\n\r\f\v]`와 동일한 표현식이다.
- `\w` - 문자+숫자(alphanumeric)와 매치, `[a-zA-Z0-9_]`와 동일한 표현식이다.
- `\W` - 문자+숫자(alphanumeric)가 아닌 문자와 매치, `[^a-zA-Z0-9_]`와 동일한 표현식이다.



#### 2.1.2 Dot(.)

- 줄바꿈 문자인 `\n`을 제외한 모든 문자와 매치됨을 의미. `a.b` 는 a와 b 사이 모든 문자를 포함해 매치한다는 뜻임.

  **예시>  "aab", "a0b", "abc"가 정규식 `a.b`와 어떻게 매치되는가?** 

  - "aab"는 가운데 문자 "a"가 모든 문자를 의미하는 `.`과 일치하므로 정규식과 매치된다.
  - "a0b"는 가운데 문자 "0"가 모든 문자를 의미하는 `.`과 일치하므로 정규식과 매치된다.
  - "abc"는 "a"문자와 "b"문자 사이에 어떤 문자라도 하나는있어야 하는 이 정규식과 일치하지 않으므로 매치되지 않는다.
    

#### 2.1.2 반복(*)

- `ca*t`는 `*` 바로 앞 문자인 a가 몇번이든 반복될 수 있다는 뜻임.

| 정규식 | 문자열 | Match 여부 | 설명                                    |
| :----- | :----- | :--------- | :-------------------------------------- |
| `ca*t` | ct     | Yes        | "a"가 0번 반복되어 매치                 |
| `ca*t` | cat    | Yes        | "a"가 0번 이상 반복되어 매치 (1번 반복) |
| `ca*t` | caaat  | Yes        | "a"가 0번 이상 반복되어 매치 (3번 반복) |



#### 2.1.2 반복(+)

- `ca+t`는 앞의 문자 a가 최소 1번 이상 반복될 때 사용 가능하다.

| 정규식 | 문자열 | Match 여부 | 설명                                    |
| :----- | :----- | :--------- | :-------------------------------------- |
| `ca+t` | ct     | No         | "a"가 0번 반복되어 매치되지 않음        |
| `ca+t` | cat    | Yes        | "a"가 1번 이상 반복되어 매치 (1번 반복) |
| `ca+t` | caaat  | Yes        | "a"가 1번 이상 반복되어 매치 (3번 반복) |



#### 2.1.2 반복({m,n}, ?)

- 반복 횟수를 m, n 사이의 수로 고정한다는 의미이다. `{1,}`은 `+`와 동일하고, `{0,}`은 `*`와 동일하다. 한 숫자만 입력되면 그 반복 회수로 정하는 것이다.

| 정규식     | 문자열  | Match 여부 | 설명                               |
| :--------- | :------ | :--------- | :--------------------------------- |
| `ca{2,5}t` | cat     | No         | "a"가 1번만 반복되어 매치되지 않음 |
| `ca{2,5}t` | caat    | Yes        | "a"가 2번 반복되어 매치            |
| `ca{2,5}t` | caaaaat | Yes        | "a"가 5번 반복되어 매치            |

- 반복은 아니지만 유사 개념으로 `?`이 있다. 뜻은 `{0,1}` 으로 있어도 되고 없어도 된다는 의미이다.

| 정규식 | 문자열 | Match 여부 | 설명                    |
| :----- | :----- | :--------- | :---------------------- |
| `ab?c` | abc    | Yes        | "b"가 1번 사용되어 매치 |
| `ab?c` | ac     | Yes        | "b"가 0번 사용되어 매치 |



### 2.2 Pyhton의 re 모듈



### 2.2.1 re 모듈

| Method     | 목적                                                         |
| :--------- | :----------------------------------------------------------- |
| match()    | 문자열의 처음부터 정규식과 매치되는지 조사한다.              |
| search()   | 문자열 전체를 검색하여 정규식과 매치되는지 조사한다.         |
| findall()  | 정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다. |
| finditer() | 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다. |



**예시>**

```python
>>> import re
>>> p = re.compile('[a-z]+')

# match
>>> m = p.match("python")
>>> print(m)
<re.Match object; span=(0, 6), match='python'>

>>> m = p.match("3 python")
>>> print(m)
None


# search
>>> m = p.search("python")
>>> print(m)
<re.Match object; span=(0, 6), match='python'>

>>> m = p.search("3 python")
>>> print(m)
<re.Match object; span=(2, 8), match='python'>


# findall
>>> result = p.findall("life is too short")
>>> print(result)
['life', 'is', 'too', 'short']


# finditer
>>> result = p.finditer("life is too short")
>>> print(result)
<callable_iterator object at 0x01F5E390>
>>> for r in result: print(r)
...
<re.Match object; span=(0, 4), match='life'>
<re.Match object; span=(5, 7), match='is'>
<re.Match object; span=(8, 11), match='too'>
<re.Match object; span=(12, 17), match='short'>
```

